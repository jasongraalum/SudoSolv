// Copyright (c) 2019 Jason Graalum,
//
// CS 531 Performance Analysis
// Portland State University
// Winter 2019
//
// Jason Graalum
// Feb 17, 2019
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <mpi.h>

#include <sudoMPISolvUtils.h>
#include <sudoMPISolvers.h>

int main(int argc, char **argv)
{
    int numProcs,procId;
    /*
    MPI_Init(&argc, &argv);
    MPI_Comm_size(MPI_COMM_WORLD, &numProcs);
    MPI_Comm_rank(MPI_COMM_WORLD, &procId);
    */

    char hostName[MPI_MAX_PROCESSOR_NAME+1];
    int name_length;
    int degree = 0; //p->degree;

    Puzzle *p;

    char *inFilename;
    char *solver;
    int repeats;


    // mpiPuzzle Datatype
    
    int puzzleBlocksCount = 4;
    int puzzleBlocksLength[4] = {1,1,1,1};
    MPI_Datatype puzzleTypes[4] = {MPI_UNSIGNED, MPI_UNSIGNED, MPI_UNSIGNED, MPI_UNSIGNED};
    MPI_Aint puzzleOffsets[4];
    MPI_Datatype mpiPuzzle;
    puzzleOffsets[0] = offsetof(Puzzle, degree);
    puzzleOffsets[1] = offsetof(Puzzle, setCount);
    puzzleOffsets[2] = offsetof(Puzzle, getCount);
    puzzleOffsets[3] = offsetof(Puzzle, cell);
    MPI_Type_create_struct(puzzleBlocksCount, puzzleBlocksLength, puzzleOffsets, puzzleTypes ,&mpiPuzzle);
    MPI_Type_commit(&mpiPuzzle);

   
    /*
    MPI_Datatype mpiCell;
    MPI_Type_create_resized(MPI_UNSIGNED, 0, sizeof(Cell), &mpiCell);
    MPI_Type_commit(&mpiCell);
    */

    if(procId == 0) {
        degree = 9;
        if(argc != 4)
        {
            printf("Usage: sudoSolv <solver> <n repeats> <starting puzzle>\n");
            exit(-1);
        }

        solver = (char*)malloc(sizeof(char)*(strlen(argv[1])+1));
        strncpy(solver,argv[1],strlen(argv[1]));
        repeats = atoi(argv[2]);
        inFilename = (char*)malloc(sizeof(char)*(strlen(argv[3])+1));
        strncpy(inFilename,argv[3],strlen(argv[3]));

        printf("Solver: %s\n", solver);
        printf("Repeats: %d\n", repeats);
        printf("Input file: %s\n", inFilename);

        p = loadPuzzle(inFilename);

        if (p == NULL) {
            printf("Error loading puzzle. Exitting.\n");
        }
        printPuzzle(p);
    }
    else {
        p = (Puzzle *)malloc(sizeof(Puzzle));
        p->degree = 0;
        p->cell = NULL;
        p->setCount = 0;
        p->getCount = 0;
    }

    // Transmit the Puzzle struct
    MPI_Bcast(p, 1, mpiPuzzle, 0, MPI_COMM_WORLD);
    MPI_Barrier(MPI_COMM_WORLD);

   // MPI_Get_processor_name(hostName, &name_length);
    //printf("%s %d %d\n", hostName, procId, p->degree);
    //MPI_Barrier(MPI_COMM_WORLD);

    if(procId == 0) printPuzzle(p);

    /*
    int cell_count = p->degree*p->degree;
    if(procId != 0) {
        p->cell = (Cell *)malloc(cell_count*sizeof(Cell));
        for(unsigned int row = 0; row < p->degree; row++)
            for(unsigned int col = 0; col < p->degree; col++)
                setCell(p,row, col, 3);
    }
    */

    /*
    if(procId == 1) printPuzzle(p);

    // Transmit the puzzle cell data

    
    MPI_Bcast(p->cell, cell_count, MPI_INT, 0, MPI_COMM_WORLD);
    MPI_Barrier(MPI_COMM_WORLD);

    if(procId == 1) printPuzzle(p);
    if(procId == 0) printPuzzle(p);

    // Now all processes have the original Puzzle.
    // Continuous loop - will break out if solution is found or queue is empty
    //treeMPISolve(p,procId,numProcs);

    */
    //MPI_Type_free(&mpiPuzzle);
    //MPI_Type_free(&mpiCell);
    if(procId == 0) {
        free(p->cell);
        free(solver);
        free(inFilename);
    }
        free(p);
    //MPI_Barrier(MPI_COMM_WORLD);
    //MPI_Finalize();
    return 0;
}

